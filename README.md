### Агентство API

#### Структура
Все просто. Сущности подрожают поведению реальных объектов, работают через контракты.

#####Пример:
- Сущность Human описывает базовые функции человека.
- Сущность Employee работник - человек, вносит новое поведение для Human не изменяя поведения своего родителя.
- Зачем? - Ну, завтра бизнес изменит требование и скажет, а давайте сдавать в аренду лошадей.
- Ок, добавим новую сущность Horse и Employee будет добавлять нужное поведение для того, чтобы сделать лошадь работником.
- Сущность Slave, работорговля не законна. Или законна?
- Есть персонал который занимается работорговлей - это менеджеры, бухгалтера и другие сотрудники. Их нельзя продать, но они имеют ставку работника, но не имеют поведение раба, которой может быть продан другой компании.

Что у нас получается?

Human -> Employee -> Менеджер = Офисный работник.
Human -> Employee -> Slave = Раб.
Лошадка -> Employee -> Slave = Лошадь которую можно продать.
Трактор -> Employee = Трактор тоже рабочий и может приносить денешку компании.
Human -> Начальник = Его точно продать нельзя и у него нет поведения обычного работника.

Такая модель может гибко давать любые комбинации сущностей.
Есть плюсы и минусы. 

**Плюсы:**
- Очень гибко можно строить что угодно, даже симбиозы трактора и начальника.
- Легко тестировать.

**Минусы**
- Другому разработчику нужно хорошо понимать как устроены модели поведения
- Нужно оперировать на уровне интерфейса (рай для явистов)
- Нужно писать больше интерфейсов.
- Может есть еще минусы но они начнуть вылазить когда аппетит бизнеса вырастит.

Далее у нас есть Провайдеры данных, они ничего не знают, только обрабатывают и валидируют данные, приводя их до нужного вида.
Думаю с ними, и так все понятно.

Далее у нас хранилища или репазитории, тут тоже все ясно, дают данные не заботясь об их целостности.
Просто нужно добавить или вернуть данные, и все.

Хотя тут есть у меня замечание, что лучше все привязать к объектам - сущностям, чтобы репазитории работали только через контракты (interface)
Но тогда тестировать будет сложнее. Тесты будут больше чем код)))

Вроде писать о приложене больше нечего, кода там мало. Все просто, магии почти нет.

####База данных

В папке database есть agency.sql это дамп.
В архитектуре используется повышенная нормализация, где есть плюсы и минусы.

**Плюсы:**
- Легко маштабировать, при нужде можно без проблем шардировать.
- Каждая таблица хранит только свои данные, которые сходятся в поведение. (Жаль в MySQL нет наследования)

**Минусы**
- Нужно писать больее сложные запросы, что замедляет работу разработчиков.

Тут надо просто искать компромисс в нормализации и исходить из требований бизнеса.

####Дополнительно
Надо бы доделать возможность установки курса валюты.
Некоторые части логики расчета или математики можно перекинуть на хранимые процедуры MySQL
Сделать больше разных исключений, и ловить в одном месте, логировать.
Отделить контроллер, а то если приложение будет расти то index.php распухнет.

Написаны тесты Unit, конечно не на все кейсы, Я люблю тестировать код как параноик, сейчас просто время было жалко, так - как это приложение никогда не будет в проде.
А, вся соль в том, что когда продукт работает еще и стабильно, можно попить кофе и закинуть ноги на стол.

Так, что там по запросам. 

####Запросы

**Получить минимальную, максимальную и среднюю стоимость всех
  рабов весом более 60 кг.**

```sql
    SELECT SUM(`cost`) AS `total_cost`, AVG(`cost`) AS `average_cost`, MIN(`cost`) AS `minimal_cost`, MAX(`cost`) AS `max_cost` 
    FROM employees 
    WHERE `weight` > 60
```
или

```sql
    SELECT SUM(`cost`) AS `total_cost`, (SUM(`cost`) / COUNT(`id`)) AS `average_cost`, MIN(`cost`) AS `minimal_cost`, MAX(`cost`) AS `max_cost` 
    FROM employees 
    WHERE `weight` > 60
```

**Выбрать категории, в которых больше 10 рабов.**

```sql
  SELECT * 
  FROM `categories` 
  WHERE `id` IN (
          SELECT `category_id`
          FROM `employee_category` 
          GROUP BY `category_id` 
          HAVING COUNT(`employee_id`) > 10
          )
```
Извиняюсь за звездочку, никогда их не использую, тут просто хотел сосридоточется на условии выборки
HAVING - Не есть хорошо, если в базе будет много строк... 


**Выбрать	категорию	с	наибольшей	суммарной	стоимостью	рабов.**

```sql
    SELECT (
        SELECT `title` 
        FROM `categories` 
        WHERE `id` =`category_id`
    ) AS `title`, SUM(`cost`) AS `total_sum` 
    FROM (
      SELECT `id`, `cost` 
      FROM `employees` 
      WHERE `id` IN (
              SELECT `employee_id` 
              FROM `employee_category`
              )
    ) AS `em`, `employee_category` AS `emc` 
    WHERE `em`.`id` = `emc`.`employee_id` 
    GROUP BY `category_id` 
    ORDER BY `total_sum` 
    DESC LIMIT 1
```
Были другие варианты, но мне понравился этот. Почему? Да незнаю, просто приглянулся и все.

**Выбрать	категории,	в	которых	мужчин	больше	чем	женщин.**

```sql
    SELECT (
        SELECT `title` 
        FROM `categories` 
        WHERE `id` =`category_id`
        ) AS `title`, COUNT(`gander`) AS `total_gander` 
        FROM (
          SELECT `id`, `gander` 
          FROM `employees` 
          WHERE `id` IN (
            SELECT `employee_id` 
            FROM `employee_category`
            ) AND `gander` = 'male') AS `em`, `employee_category` AS `emc` 
    WHERE `em`.`id` = `emc`.`employee_id` 
    GROUP BY `category_id` 
    ORDER BY `total_gander` 
    DESC 

```

Тут вроде Я накосячил. Хотя....

**Количество	рабов	в	категории	"Для	кухни"	(включая	все
  вложенные	категории).**
  
```sql
  SELECT COUNT(`id`) AS `count_employee` 
  FROM `employees` 
  WHERE `id` IN (
      SELECT `employee_id` 
      FROM `employee_category` 
      LEFT JOIN `categories` ON `categories`.`title` LIKE "%cleaning%")
```

Тут просто, в LIKE указать нужную категорию и получить всех работников подкатегории тоже. 
Если поиск всегда будет использоватся через LIKE надо бы повесить текстовый индекс на поле.

Ну, вот. По запросам вроде все. Может что запартачил. 

Категории используют цикличную внутренюю связь через parent id. Это дает преимущество иметь любую глубину категорий, но будет сложно читать. 

Запросы могу не показывать достаточно данных, нужно запихать больше данных в базу.

####Как работать (Запустить)

Для ответов используется JSON + JSend

Думаю с деплоем все просто.

Клонируем репазиторий.

Запускаем тесты 
```bash
    $php vendor/bin/phpunit tests/unit --color
```
--color просто чтоб было красиво.

Если тесты прошли, хорошо. Сломались, плохо.

Далее надо установить зависимости. Ах да, чуть не забыл, надо поставить composer

```bash
    $php composer install
```
Если все ок. Пробуем запускать

```bash
    $php -S localhost:8080
```

####Документация

**Добовление нового работника в базу POST**

Path: /api/employee/add

Тело: 

```forma
    name: Robert //Имя
    age: 50 //Возраст
    weight: 80 //Вес
    gander: male //Пол
    color: black //Цвет кожи
    description: Super employee //Описание
    rate: 10 //Ставка за час работы
    cost: 500 //Строймость 
```

Результат:

```json
{
  "status": "success",
  "data": {
    "name": "New",
    "age": 37,
    "weight": 55,
    "gander": "male",
    "color": "black",
    "description": "From cat",
    "rate": 6,
    "cost": 300
  }
}

```

**Получение списка работников GET**

Path: /api/employee/?limit=2&offset=1

limit и offset не обязательные, это типо пагинации.

Результат:

```json
{
  "status": "success",
  "data": [
    {
      "id": "3",
      "name": "New",
      "age": "37",
      "weight": "82",
      "gander": "male",
      "color": "black",
      "description": "From cat",
      "rate": "6",
      "cost": "300"
    },
    {
      "id": "4",
      "name": "New",
      "age": "37",
      "weight": "82",
      "gander": "male",
      "color": "black",
      "description": "From cat",
      "rate": "6",
      "cost": "300"
    }
  ]
}
```

**Получить статус работника GET**

Path: /api/employee/status/id/1

После id надо указывать id работника.

Результат (если работник свободен):
 
```sql
    {
      "status": "success",
      "data": {
        "status": "free"
      }
    }
```

Результат (если работник занят):

```json
{
  "status": "success",
  "data": {
    "status": "busy",
    "employee_id": "2",
    "start_work": "2017-05-01 16:29:20",
    "finish_work": "2017-05-01 21:30:20",
    "he_doing": "carpet cleaning"
  }
}

```

Тут тоже Я накосячил, надо было дать клиенту указывать на какое время нужен ему работник. А сейчас проверяет на текущее время.
Хотя, можно будет реализовать планирование наперед.

**Получение полной информации о работнике GET**

Path: api/employee/info/id/1

```json
{
  "status": "success",
  "data": {
    "name": "Test",
    "age": "25",
    "weight": "70",
    "gander": "male",
    "color": "black",
    "description": "From messa ",
    "rate": "10",
    "cost": "500",
    "categories": [
      {
        "id": "1",
        "title": "cleaning"
      },
      {
        "id": "2",
        "title": "cleaning room"
      }
    ]
  }
}
```

**Нанять работника**

Path: /api/employee/rent

Тело:

```form
employee_id: 1 //ID Работника
from: 2017-04-29 16:29:20 //Начало аренды
to: 2017-04-29 16:29:20 //Конец аренды
action_id: 2 //ID Действие, что будет делать рабоник.
client_id: 4 //Наниматель
```

Результат:

```json
{
  "status": "success",
  "data": {
    "total_cost": 40
  }
}

```

Надо бы еще выводить в головах по курсу.
И еще надо обрабатывать ошибки.

**Добавление нового курса, голов к золоту POST**

Path: /api/exchange/add

Тело:

```form
cost: 10 //Сколько голов скота за одну золотую монетку
data: 2017-04-29 16:29:20  //Актуальность даты
```

Извините, этот метод Я не успел реализовать.

Еще не успел сделать диаграмму классов
Вот что есть. 

Там в корне проекта есть файль Agency.postman_collection.json это готовые запроса для приложение Postman

Прикладываю схему таблиц.

![alt tag](https://raw.githubusercontent.com/monster3d/Agency/database/database.jpg)


